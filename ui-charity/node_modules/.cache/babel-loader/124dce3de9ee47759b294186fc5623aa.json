{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar helper_1 = require(\"../actions/helper\");\n\nvar Error_1 = require(\"../actions/Error\");\n\nvar Print_1 = require(\"../actions/Print\");\n\nvar MessageTransport_1 = require(\"../MessageTransport\");\n\nvar collection_1 = require(\"../util/collection\");\n\nvar shared_1 = require(\"../util/shared\");\n\nvar env_1 = require(\"../util/env\");\n\nvar print_1 = require(\"./print\");\n\nvar redirect_1 = require(\"./redirect\");\n\nvar modal_1 = require(\"./modal\");\n\nvar types_1 = require(\"./types\");\n\nvar Hooks_1 = __importDefault(require(\"./Hooks\"));\n\nexports.WINDOW_UNDEFINED_MESSAGE = 'window is not defined. Running an app outside a browser is not supported';\n\nfunction redirectHandler(hostFrame, config) {\n  var apiKey = config.apiKey,\n      shopOrigin = config.shopOrigin,\n      _a = config.forceRedirect,\n      forceRedirect = _a === void 0 ? !env_1.isDevelopmentClient : _a;\n  var location = redirect_1.getLocation();\n\n  if (env_1.isFrameless || !location || !apiKey || !shopOrigin || !forceRedirect || !redirect_1.shouldRedirect(hostFrame)) {\n    return;\n  }\n\n  var url = \"https://\" + shopOrigin + \"/admin/apps/\" + apiKey + location.pathname + (location.search || '');\n  redirect_1.redirect(url);\n}\n\nfunction appSetUp(app) {\n  app.subscribe(Print_1.ActionType.APP, print_1.handleAppPrint);\n  modal_1.setupModalAutoSizing(app);\n}\n/**\n * Extracts the query parameters from the current URL.\n * @deprecated This function has been deprecated.\n * @public\n */\n\n\nfunction getUrlParams() {\n  var params = {};\n  var location = redirect_1.getLocation();\n\n  if (!location) {\n    return params;\n  }\n\n  var hashes = location.search.slice(location.search.indexOf('?') + 1).split('&');\n  return hashes.reduce(function (acc, hash) {\n    var _a;\n\n    var _b = hash.split('='),\n        key = _b[0],\n        val = _b[1];\n\n    return __assign({}, acc, (_a = {}, _a[decodeURIComponent(key)] = decodeURIComponent(val), _a));\n  }, params);\n}\n\nexports.getUrlParams = getUrlParams;\n/**\n * Extracts the `shop` query parameter from the current URL.\n * @deprecated This function has been deprecated, see {@link https://help.shopify.com/api/embedded-apps/shop-origin}\n * @public\n */\n\nfunction getShopOrigin() {\n  var params = getUrlParams();\n  return params.shop;\n}\n\nexports.getShopOrigin = getShopOrigin;\n/**\n * @internal\n */\n\nexports.createClientApp = function (transport, middlewares) {\n  if (middlewares === void 0) {\n    middlewares = [];\n  }\n\n  var getStateListeners = [];\n  var listeners = [];\n  var actionListeners = {};\n\n  var invokeCallbacks = function (type, payload) {\n    var hasCallback = false;\n\n    if (actionListeners.hasOwnProperty(type)) {\n      for (var _i = 0, _a = actionListeners[type]; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        var id = listener.id,\n            callback = listener.callback;\n        var matchId = payload && payload.id === id;\n\n        if (matchId || !id) {\n          callback(payload);\n          hasCallback = true;\n        }\n      }\n    }\n\n    if (hasCallback) {\n      return;\n    } // Throw an error if there are no subscriptions to this error\n\n\n    var errorType = helper_1.findMatchInEnum(Error_1.ActionType, type);\n\n    if (errorType) {\n      Error_1.throwError(errorType, payload);\n    }\n  };\n\n  var handler = function (event) {\n    var action = event.data;\n\n    switch (action.type) {\n      case 'getState':\n        var resolvers = getStateListeners.splice(0);\n        resolvers.forEach(function (resolver) {\n          return resolver(action.payload);\n        });\n        break;\n\n      case 'dispatch':\n        var payload_1 = action.payload;\n        invokeCallbacks(payload_1.type, payload_1.payload);\n        listeners.forEach(function (listener) {\n          return listener.callback(payload_1);\n        });\n        break;\n\n      default: // Silently swallow unknown actions\n\n    }\n  };\n\n  transport.subscribe(handler);\n  return function (config) {\n    if (!config.shopOrigin) {\n      throw Error_1.fromAction('shopOrigin must be provided', Error_1.AppActionType.INVALID_CONFIG);\n    }\n\n    var protocol = /^https?:\\/\\//;\n\n    if (protocol.test(config.shopOrigin)) {\n      var message = \"shopOrigin should not include protocol, please use: \" + config.shopOrigin.replace(protocol, '');\n      throw Error_1.fromAction(message, Error_1.AppActionType.INVALID_CONFIG);\n    }\n\n    if (!config.apiKey) {\n      throw Error_1.fromAction('apiKey must be provided', Error_1.AppActionType.INVALID_CONFIG);\n    }\n\n    var dispatcher = createDispatcher(transport, config); // It is possible to initialize an app multiple times\n    // Therefore we need to clear subscriptions to be safe\n\n    dispatcher(types_1.MessageType.Unsubscribe);\n\n    function dispatch(action) {\n      dispatcher(types_1.MessageType.Dispatch, action);\n      return action;\n    }\n\n    redirectHandler(transport.hostFrame, config);\n    var hooks = new Hooks_1.default();\n    var app = {\n      localOrigin: transport.localOrigin,\n      hooks: hooks,\n      dispatch: function (action) {\n        if (!app.hooks) {\n          return dispatch(action);\n        }\n\n        return app.hooks.run(types_1.LifecycleHook.DispatchAction, dispatch, app, action);\n      },\n      featuresAvailable: function (features) {\n        return app.getState('features').then(function (state) {\n          if (features) {\n            Object.keys(state).forEach(function (feature) {\n              if (!features.includes(feature)) {\n                delete state[feature];\n              }\n            });\n          }\n\n          return state;\n        });\n      },\n      getState: function (query) {\n        return new Promise(function (resolve) {\n          getStateListeners.push(resolve);\n          dispatcher(types_1.MessageType.GetState);\n        }).then(function (state) {\n          if (query) {\n            return query.split('.').reduce(function (value, key) {\n              if (typeof state !== 'object' || Array.isArray(state)) {\n                return undefined;\n              }\n\n              value = state[key];\n              state = value;\n              return value;\n            }, undefined);\n          }\n\n          return state;\n        });\n      },\n      subscribe: function () {\n        if (arguments.length < 2) {\n          return collection_1.addAndRemoveFromCollection(listeners, {\n            callback: arguments[0]\n          });\n        }\n\n        var type = arguments[0];\n        var callback = arguments[1];\n        var id = arguments[2];\n        var actionCallback = {\n          callback: callback,\n          id: id\n        };\n        var payload = {\n          type: type,\n          id: id\n        };\n\n        if (!actionListeners.hasOwnProperty(type)) {\n          actionListeners[type] = [];\n        }\n\n        dispatcher(types_1.MessageType.Subscribe, payload);\n        return collection_1.addAndRemoveFromCollection(actionListeners[type], actionCallback, function () {\n          return dispatcher(types_1.MessageType.Unsubscribe, payload);\n        });\n      },\n      error: function (listener, id) {\n        var _this = this;\n\n        var unsubscribeCb = [];\n        helper_1.forEachInEnum(Error_1.ActionType, function (eventNameSpace) {\n          // tslint:disable-next-line:no-invalid-this\n          unsubscribeCb.push(_this.subscribe(eventNameSpace, listener, id));\n        });\n        return function () {\n          unsubscribeCb.forEach(function (unsubscribe) {\n            return unsubscribe();\n          });\n        };\n      }\n    };\n\n    for (var _i = 0, middlewares_1 = middlewares; _i < middlewares_1.length; _i++) {\n      var middleware = middlewares_1[_i];\n      middleware(hooks, app);\n    }\n\n    appSetUp(app);\n    return app;\n  };\n};\n/**\n * @public\n */\n\n\nfunction createAppWrapper(frame, localOrigin, middleware) {\n  if (middleware === void 0) {\n    middleware = [];\n  }\n\n  if (!frame) {\n    throw Error_1.fromAction(exports.WINDOW_UNDEFINED_MESSAGE, Error_1.AppActionType.WINDOW_UNDEFINED);\n  }\n\n  var location = redirect_1.getLocation();\n  var origin = localOrigin || location && location.origin;\n\n  if (!origin) {\n    throw Error_1.fromAction('local origin cannot be blank', Error_1.AppActionType.MISSING_LOCAL_ORIGIN);\n  }\n\n  var transport = MessageTransport_1.fromWindow(frame, origin);\n  var appCreator = exports.createClientApp(transport, middleware);\n  return appCreator;\n}\n\nexports.createAppWrapper = createAppWrapper;\n/**\n * Creates your application instance.\n * @param config - Both `apiKey` and `shopOrigin` are required.\n * @remarks\n * You will need to store `shopOrigin` during the authentication process and then retrieve it for the code to work properly. To learn more about this process, see {@link https://help.shopify.com/api/embedded-apps/shop-origin | Getting and storing the shop origin}.\n * @public\n */\n\nfunction createApp(config) {\n  var currentWindow = redirect_1.getWindow();\n\n  if (!currentWindow) {\n    return shared_1.serverAppBridge;\n  }\n\n  return createAppWrapper(currentWindow.top)(config);\n}\n\nexports.createApp = createApp;\n\nfunction createDispatcher(transport, config) {\n  return function (type, payload) {\n    transport.dispatch({\n      payload: payload,\n      source: config,\n      type: type\n    });\n  };\n}\n/**\n * {@inheritdocs createApp}\n * @public\n */\n\n\nexports.default = createApp;","map":null,"metadata":{},"sourceType":"script"}